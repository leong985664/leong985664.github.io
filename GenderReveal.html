<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Gender Reveal Puzzle Arena</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    :root {
      --bg: #0f172a;
      --bg-soft: #111827;
      --card: #020617;
      --accent: #f97316;
      --accent-soft: rgba(249, 115, 22, 0.16);
      --accent-strong: rgba(249, 115, 22, 0.28);
      --text: #e5e7eb;
      --text-soft: #9ca3af;
      --border: #1f2937;
      --error: #f97373;
      --success: #4ade80;
      --hint: #eab308;
      --radius-xl: 18px;
      --radius-lg: 12px;
      --shadow-soft: 0 22px 45px rgba(15, 23, 42, 0.85);
      --shadow-chip: 0 10px 25px rgba(15, 23, 42, 0.85);
      --transition-fast: 0.15s ease-out;
      --transition: 0.22s ease-out;
      --font-main: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      height: 100vh;
      font-family: var(--font-main);
      background:
        radial-gradient(circle at top left, #1f2937 0, #020617 55%),
        radial-gradient(circle at 120% 0, #111827 0, #020617 55%),
        #020617;
      color: var(--text);
      display: flex;
      justify-content: center;
      padding: 24px 16px;
    }

    .app-shell {
      width: 100%;
      max-width: 1080px;
      background: linear-gradient(145deg, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.94));
      border-radius: 32px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      box-shadow: var(--shadow-soft);
      padding: 26px 24px 28px;
      position: relative;
      overflow: hidden;

      display: flex;
      flex-direction: column;
      height: 100%;
      max-height: 100%;
    }

    @media (min-width: 768px) {
      .app-shell {
        padding: 28px 30px 30px;
      }
    }

    .app-shell::before,
    .app-shell::after {
      content: "";
      position: absolute;
      border-radius: 999px;
      filter: blur(42px);
      opacity: 0.8;
      pointer-events: none;
    }

    .app-shell::before {
      width: 280px;
      height: 280px;
      background: radial-gradient(circle, var(--accent-strong), transparent);
      top: -120px;
      right: -80px;
    }

    .app-shell::after {
      width: 220px;
      height: 220px;
      background: radial-gradient(circle, rgba(52, 211, 153, 0.35), transparent);
      bottom: -100px;
      left: -60px;
    }

    header {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 10px;
      flex-shrink: 0;
    }

    .chip-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 6px;
    }

    .chip {
      padding: 5px 10px;
      border-radius: 999px;
      font-size: 11px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      border: 1px solid rgba(148, 163, 184, 0.55);
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.85);
      box-shadow: var(--shadow-chip);
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .chip span.spark {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: var(--accent);
      box-shadow: 0 0 12px rgba(249, 115, 22, 0.85);
    }

    .title-row {
      display: flex;
      flex-wrap: wrap;
      align-items: baseline;
      gap: 10px;
    }

    h1 {
      font-size: clamp(22px, 3vw, 26px);
      margin: 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .title-badge {
      font-size: 10px;
      text-transform: uppercase;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(248, 250, 252, 0.18);
      background: linear-gradient(135deg, rgba(15, 23, 42, 0.95), rgba(15, 23, 42, 0.8));
      color: var(--accent);
      letter-spacing: 0.12em;
    }

    /* é¡¶éƒ¨ä¸¤å—ï¼šå·¦è¯´æ˜ï¼Œå³æ§åˆ¶æ¡ */

    .top-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 8px;
      flex-shrink: 0;
      position: relative;
      z-index: 1;
    }

    .intro-card {
      flex: 1 1 450px;
      min-width: 0;
      border-radius: 20px;
      border: 1px solid rgba(148, 163, 184, 0.45);
      background: radial-gradient(circle at top left, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.9));
      padding: 10px 12px 10px;
      box-shadow: 0 12px 28px rgba(15, 23, 42, 0.85);
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .intro-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--text-soft);
      margin-bottom: 2px;
    }

    .intro-text {
      font-size: 12px;
      color: var(--text-soft);
      line-height: 1.5;
    }

    .intro-text strong {
      color: #e5e7eb;
      font-weight: 500;
    }

    .intro-phrase {
      margin-top: 10px;
    }

    .control-panel {
      flex: 1 1 250px;
      min-width: 0;
      position: relative;
      z-index: 1;
      border-radius: 20px;
      border: 1px solid rgba(30, 64, 175, 0.6);
      background: radial-gradient(circle at top left, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.9));
      padding: 10px 12px 10px;
      box-shadow: 0 16px 36px rgba(15, 23, 42, 0.9);
      display: flex;
      flex-direction: column;
      gap: 6px;
      flex-shrink: 0;
    }

    .control-subtitle {
        font-size: 9px;
        color: rgba(148, 163, 184, 0.75);
        letter-spacing: 0.08em;
        margin-top: -2px;
        line-height: 1.3;
    }

    .control-main-row {
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 8px;
    }

    .control-main {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .timer-block,
    .stats-block {
      display: flex;
      flex-direction: column;
      gap: 1px;
      width: 100%;
    }

    .control-label {
      font-size: 10px;
      letter-spacing: 0.13em;
      text-transform: uppercase;
      color: var(--text-soft);
    }

    .timer-display-main {
      font-variant-numeric: tabular-nums;
      font-size: 18px;
      font-weight: 600;
      letter-spacing: 0.14em;
    }

    .control-actions {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-start;
    }

    .control-rules {
      font-size: 10px;
      color: rgba(148, 163, 184, 0.9);
      line-height: 1.4;
    }

    @media (max-width: 768px) {
      .control-main-row {
        align-items: flex-start;
      }
      .timer-display-main {
        font-size: 16px;
      }
    }

    button {
      border-radius: 999px;
      border: none;
      padding: 7px 12px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: transform var(--transition-fast), box-shadow var(--transition-fast), background var(--transition-fast), color var(--transition-fast);
      white-space: nowrap;
    }

    button.primary {
      background: linear-gradient(135deg, #f97316, #fb923c);
      color: #0b1120;
      box-shadow: 0 10px 26px rgba(248, 153, 72, 0.35);
    }

    button.primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 14px 32px rgba(248, 153, 72, 0.5);
    }

    button.primary:active {
      transform: translateY(0);
      box-shadow: 0 6px 16px rgba(248, 153, 72, 0.45);
    }

    button.outline {
      background: rgba(15, 23, 42, 0.96);
      color: var(--text-soft);
      border: 1px solid rgba(75, 85, 99, 0.85);
      padding-inline: 10px;
    }

    button.outline:hover {
      background: rgba(15, 23, 42, 1);
      color: #e5e7eb;
      border-color: rgba(148, 163, 184, 0.95);
      transform: translateY(-1px);
      box-shadow: 0 10px 26px rgba(15, 23, 42, 0.9);
    }

    button.small {
      padding: 4px 9px;
      font-size: 11px;
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    /* å½“å‰å¥å­è¿›åº¦ï¼ˆåµŒåœ¨ intro-card é‡Œï¼‰ */

    .phrase-bar {
      border-radius: 18px;
      border: 1px solid rgba(30, 64, 175, 0.5);
      background: radial-gradient(circle at top left, rgba(15, 23, 42, 0.95), rgba(15, 23, 42, 0.9));
      padding: 8px 10px;
      box-shadow: 0 10px 22px rgba(15, 23, 42, 0.7);
    }

    .phrase-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      color: var(--text-soft);
      margin-bottom: 4px;
    }

    .phrase-text {
      font-size: 14px;
      font-weight: 500;
      letter-spacing: 0.16em;
      word-spacing: 0.25em;
      text-transform: uppercase;
      white-space: normal;
      word-wrap: break-word;
    }

    .phrase-text span.word {
      margin-right: 4px;
    }

    .phrase-text span.word.completed {
      color: #fbbf24;
    }

    /* é¡¶éƒ¨åˆ†å‰²çº¿ï¼ˆå›ºå®šï¼Œä¸éšè°œé¢˜æ»šåŠ¨ï¼‰ */

    .top-divider {
      border-top: 1px solid rgba(148, 163, 184, 0.4);
      margin: 8px 0 10px;
      opacity: 0.9;
      flex-shrink: 0;
      position: relative;
      z-index: 1;
    }

    /* ä¸‹åŠéƒ¨åˆ†ï¼šåªæ»šåŠ¨è°œé¢˜åˆ—è¡¨ */

    .puzzle-section {
      position: relative;
      z-index: 1;
      margin-top: 0;
      flex: 1 1 auto;
      min-height: 0;
      overflow-y: auto;
      padding-right: 4px;
    }

    .puzzle-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding-bottom: 8px;
    }

    .puzzle-card {
      background: radial-gradient(circle at top left, var(--bg-soft), var(--card));
      border-radius: var(--radius-xl);
      border: 1px solid rgba(30, 64, 175, 0.4);
      padding: 14px 14px 12px;
      position: relative;
      overflow: hidden;
    }

    .puzzle-card::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 0 -40%, rgba(248, 250, 252, 0.04), transparent 60%);
      opacity: 1;
      pointer-events: none;
    }

    .puzzle-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
      position: relative;
      z-index: 1;
    }

    .puzzle-title {
      display: flex;
      align-items: baseline;
      gap: 6px;
    }

    .puzzle-label {
      font-size: 11px;
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }

    .puzzle-name {
      font-size: 13px;
      color: #e5e7eb;
      font-weight: 500;
    }

    .puzzle-meta {
      font-size: 11px;
      color: var(--text-soft);
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .pill {
      border-radius: 999px;
      padding: 3px 8px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.9);
      font-size: 10px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    .pill.solved {
      border-color: rgba(34, 197, 94, 0.85);
      color: var(--success);
    }

    .pill.pending {
      border-color: rgba(148, 163, 184, 0.8);
      color: var(--text-soft);
    }

    .word-length {
      opacity: 0.9;
    }

    .puzzle-body {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .puzzle-hint-text {
      font-size: 11px;
      color: var(--text-soft);
      line-height: 1.45;
      margin-bottom: 2px;
    }

    .input-row {
      display: grid;
      grid-template-columns: minmax(0, 1fr) auto;
      gap: 6px;
    }

    input[type="text"] {
      width: 100%;
      border-radius: var(--radius-lg);
      border: 1px solid rgba(55, 65, 81, 0.95);
      padding: 8px 10px;
      background: rgba(15, 23, 42, 0.95);
      color: var(--text);
      font-size: 13px;
      outline: none;
      transition: border-color var(--transition-fast), box-shadow var(--transition-fast), background var(--transition-fast), transform var(--transition-fast);
    }

    input[type="text"]::placeholder {
      color: rgba(148, 163, 184, 0.7);
    }

    input[type="text"]:focus {
      border-color: rgba(249, 115, 22, 0.9);
      box-shadow: 0 0 0 1px rgba(249, 115, 22, 0.7);
      background: rgba(12, 18, 32, 0.98);
      transform: translateY(-0.5px);
    }

    .feedback {
      min-height: 18px;
      font-size: 11px;
      margin-top: 2px;
    }

    .feedback.error {
      color: var(--error);
    }

    .feedback.success {
      color: var(--success);
    }

    .feedback.info {
      color: var(--text-soft);
    }

    .controls-row {
      display: flex;
      flex-direction: column;
      align-items: flex-start;  /* hint æŒ‰é’®å·¦å¯¹é½ */
      gap: 4px;
      margin-top: 4px;
    }

    .hint-buttons-box {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
      justify-content: flex-start; /* æ˜ç¡®å·¦å¯¹é½ */
    }

    .hint-lines-block {
      margin-top: 4px;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .hint-line {
      font-size: 11px;
      color: var(--hint);
      display: none;
    }

    .hint-line.visible {
      display: block;
    }

    /* æ–°å¢æ ·å¼ï¼šå…¨éƒ¨å®Œæˆæ—¶çš„ç»¿è‰² */
    .all-completed {
      color: #34d399;
      text-shadow: 0 0 8px rgba(52, 211, 153, 0.7);
    }

    /* æ–°å¢æ ·å¼ï¼šé”å®šçŠ¶æ€ */
    .pill.locked {
      border-color: rgba(249, 115, 22, 0.85);
      color: rgba(249, 115, 22, 0.85);
      background: rgba(15, 23, 42, 0.9);
      position: relative;
    }

    .pill.locked::before {
      content: "ğŸ”’";
      position: absolute;
      left: -6px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <header>
      <div class="chip-row">
        <div class="chip">
          <span class="spark"></span>
          GENDER REVEAL Â· PUZZLE ARENA
        </div>
        <div class="chip">
          7 PUZZLES Â· 2 TEAMS Â· 1 SECRET
        </div>
      </div>

      <div class="title-row">
        <h1>
          Puzzle Lab - A Journey Toward the Reveal
          <span class="title-badge">Presented by Yulong Liang & Yeqing Kong</span>
        </h1>
      </div>
    </header>

    <!-- é¡¶éƒ¨ä¸¤å—ï¼šå·¦ä»‹ç»æ¡† + å³æ§åˆ¶æ¡ -->
    <div class="top-row">
      <section class="intro-card">
        <div class="intro-title">æ¸¸æˆè¯´æ˜</div>
        <div class="intro-text">
          å®¾å®¢å¹³å‡åˆ†æˆä¸¤é˜Ÿï¼Œè§£è°œ7é“é¢˜ç›®ï¼Œç”¨æ—¶æ›´çŸ­è€…è·èƒœã€‚
          æ¯é¢˜å¾—åˆ°ä¸€ä¸ª<strong>è‹±æ–‡å•è¯</strong>ã€‚
          æç¤ºæ¬¡æ•°ä¸é™ï¼Œä½†æ¯ä½¿ç”¨1æ¬¡æç¤ºï¼Œæ€»æ—¶é—´ä¼šè‡ªåŠ¨å¢åŠ <strong>5åˆ†é’Ÿ</strong>ã€‚
          å…¨éƒ¨å•è¯ç­”å¯¹åï¼Œå°±èƒ½æ‹¼å‡ºé‚£å¥ç”¨æ¥å”¤é†’æƒŠå–œçš„è¯è¯­ã€‚
        </div>
        <div class="intro-title">How to Play</div>
        <div class="intro-text">
          Guests are divided into two teams to solve 7 puzzles, with the faster team winning.
          Each puzzle yields one <strong>English word</strong>.
          Hints are unlimited, but each hint used automatically adds <strong>5 minutes</strong> to the total time.
          When all words are correct, they form the sentence that unlocks the surprise.
        </div>

        <!-- å½“å‰å¥å­è¿›åº¦åµŒåœ¨è¯´æ˜å¡ç‰‡é‡Œ -->
        <div class="intro-phrase">
          <div class="phrase-bar">
            <div class="phrase-label">å½“å‰è¿›åº¦ Â· Current Progress</div>
            <div class="phrase-text" id="phrase-bar"></div>
          </div>
        </div>
      </section>

      <section class="control-panel">
        <div class="control-main-row">
          <div class="control-main">
            <div class="timer-block">
              <div class="control-label">è§£é¢˜ç”¨æ—¶ Â· Puzzle Time</div>
              <div class="timer-display-main" id="timer-display">00:00</div>
            </div>
            <div class="timer-block">
              <div class="control-label">æ€»æ—¶é—´ Â· Total Time</div>
              <div class="timer-display-main" id="total-time-display">00:00</div>
              <div class="control-subtitle">(åŒ…å«æç¤ºåŠ æ—¶ Â· Including Hint Cost)</div>
            </div>
            <div class="stats-block">
              <div class="control-label">å·²ç”¨æç¤º Â· Hints Used</div>
              <div class="timer-display-main" id="hints-used-display">0</div>
            </div>
          </div>

          <div class="control-actions">
            <button class="primary" id="start-timer-btn">
              â–¶ Start
            </button>
            <button class="outline" id="reset-timer-btn">
              âŸ³ Reset Game
            </button>
          </div>
        </div>

        <div class="control-rules">
        </div>
      </section>
    </div>

    <!-- å›ºå®šåˆ†å‰²çº¿ï¼ˆä¸éšè°œé¢˜æ»šåŠ¨ï¼‰ -->
    <div class="top-divider"></div>

    <!-- è°œé¢˜åˆ—è¡¨ï¼ˆæ»šåŠ¨ï¼‰ -->
    <section class="puzzle-section">
      <div class="puzzle-list" id="puzzle-list"></div>
    </section>
  </div>

  <script>
    // =============================
    // é…ç½®åŒºï¼šä¸ƒä¸ªè°œé¢˜
    // =============================

    const puzzles = [
      {
        id: "p1",
        title: "Where Stories Joined",
        expectedAnswer: "UNION",
        hints: [
          "Try looking at the characters upside down, what can you see?",
          "Once you find the correct coordinates, look it up on your favorite map app. What is the name of the lake?"
        ]
      },
      {
        id: "p2",
        title: "Paths for a Little Miracle",
        expectedAnswer: "OF",
        hints: [
          "Identify each place from the photos and locate them on the map.",
          "After locating the places, connect them as described. The shape of the route is the letter you need."
        ]
      },
      {
        id: "p3",
        title: "å¤å£°åˆå¯",
        expectedAnswer: "LOVE",
        hints: [
          "åœ¨å…«é¦–è¯—è¯ä¸­ï¼Œæ‰¾åˆ°æœ€ç¬¦åˆæè¿°çš„ä¸€é¦–â€”â€”ã€Šå…³é›ã€‹ã€‚",
          "æ‰¾åˆ°æœ€ç¬¦åˆè¦æ±‚çš„è¯—è¯åï¼Œå°†å…¶ä¸­æ‰€æœ‰çš„çº¢è‰²åæ—éƒ¨é¦–ç»„åˆèµ·æ¥ï¼Œå¾—åˆ°ä¸€ä¸ªå­—ï¼ˆç¹ä½“ï¼‰ã€‚å°†å¾—åˆ°çš„å­—ç¿»è¯‘æˆè‹±æ–‡ã€‚"
        ]
      },
      {
        id: "p4",
        title: "The Script of New Life",
        expectedAnswer: "BLOOMS",
        hints: [
          "Follow the direction of the strand and read the colors from 3' to 5'. Use the color map to identify each of the four DNA bases: Red â†’ A, Blue â†’ C, Green â†’ G, Yellow â†’ T. These colors represent the complementary DNA sequence. Apply base pairing (switch A with T and vice versa, switch C with G and vice versa) to convert each base into its actual partner. For example, AGTC â†’ TCAG.",
          "Group the DNA bases into triplets (three letters per group). For each triplet (X, Y, Z), compute its value using: 16Ã—X + 4Ã—Y + Z + 1, where X, Y, and Z are the value of the 1st, 2nd, and 3rd DNA base in the group. The DNA bases have the following values: A = 0, C = 1, G = 2, T = 3. Use the resulting number (1â€“26) as the position of the letter in the alphabet to find the corresponding letter. For example: Triplet (A, C, G) â†’ 16Ã—0 + 4Ã—1 + 2 + 1 = 7 â†’ G (7th letter of the alphabet)."
        ]
      },
      {
        id: "p5",
        title: "A Moment in Time",
        expectedAnswer: "NOW",
        hints: [
          "Convert the time on each clock to Atlanta's time zone (EST). They point to the same time.",
          "Find the correct time and write it in digital format (omit leading 0s). Turn 90 degrees clockwise and see what letter you can see for each number."
        ]
      },
      {
        id: "p6",
        title: "Puzzle Suite",
        expectedAnswer: "IN",
        hints: [
          "In the first puzzle, look at a QWERTY keyboard. Each tennis ball represent a letter.",
          "In the first puzzle, use the position of each pink ball to read the letters. Form a word with the letters.",
          "In the second puzzle, each ball represent a different number according to the game rules. The number of snooker balls (red, yellow, green, brown, blue, pink, and black) is their point value. The number of the poll balls are written on the balls.",
          "In the second puzzle, use the number of the ball to get the position of the letter in the word. Put the letters into those numbered spots to find the word.",
          "In the final puzzle, take only the highlighted letters from the first two answers to extract two short words.",
          "In the final puzzle, recall your favorite office softwares from Microsoft and get the third word. Extract the highlighted letters to reveal the final answer."
        ]
      },
      {
        id: "p7",
        title: "Across Our Moments",
        expectedAnswer: "HARMONY",
        hints: [
          "Each photo contains a hidden letter. Identify all seven of them.",
          "Find all seven letters and read them in chronological order â€” they spell the answer."
        ]
      }
    ];

    const MIN_INTERVAL_MS = 10 * 1000;
    const HINT_PENALTY_MS = 5 * 60 * 1000;
    const STORAGE_KEY = "genderRevealPuzzleState_v3";

    const puzzleState = {};
    puzzles.forEach(p => {
      puzzleState[p.id] = {
        lastAttemptAt: 0,
        solved: false,
        attempts: 0,
        hintsUsed: 0,
        usedHints: []
      };
    });

    let timerIntervalId = null;
    let timerStartTimestamp = null;
    let elapsedBeforePause = 0;

    // =============================
    // çŠ¶æ€å­˜å‚¨
    // =============================

    function saveStateToStorage() {
      const data = {
        version: 3,
        timerStartTimestamp,
        elapsedBeforePause,
        puzzleState
      };
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      } catch (e) {
        console.warn("Failed to save state:", e);
      }
    }

    function loadStateFromStorage() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return;
        const data = JSON.parse(raw);
        if (!data || data.version !== 3) return;

        if (typeof data.timerStartTimestamp === "number") {
          timerStartTimestamp = data.timerStartTimestamp;
        }
        if (typeof data.elapsedBeforePause === "number") {
          elapsedBeforePause = data.elapsedBeforePause;
        }
        if (data.puzzleState) {
          for (const id of Object.keys(data.puzzleState)) {
            if (puzzleState[id]) {
              const s = data.puzzleState[id];
              puzzleState[id].lastAttemptAt = s.lastAttemptAt || 0;
              puzzleState[id].solved = !!s.solved;
              puzzleState[id].attempts = s.attempts || 0;
              puzzleState[id].hintsUsed = s.hintsUsed || 0;
              puzzleState[id].usedHints = Array.isArray(s.usedHints)
                ? s.usedHints.map(Boolean)
                : [];
            }
          }
        }
      } catch (e) {
        console.warn("Failed to load state:", e);
      }
    }

    // =============================
    // å¥å­è¿›åº¦æ¡
    // =============================

    function renderPhraseBar() {
      const bar = document.getElementById("phrase-bar");
      if (!bar) return;
      bar.innerHTML = "";

      const allSolved = puzzles.every(p => puzzleState[p.id].solved);

      const frag = document.createDocumentFragment();
      puzzles.forEach(p => {
        const state = puzzleState[p.id];
        const span = document.createElement("span");
        span.className = "word";
        const len = p.expectedAnswer.replace(/\s+/g, "").length;
        if (state.solved) {
          span.textContent = p.expectedAnswer.toUpperCase();
          span.classList.add(allSolved ? "all-completed" : "completed");
        } else {
          span.textContent = "_".repeat(len);
        }
        frag.appendChild(span);
        frag.appendChild(document.createTextNode(" "));
      });

      bar.appendChild(frag);

      if (allSolved && timerIntervalId !== null) {
        clearInterval(timerIntervalId);
        timerIntervalId = null;
      }
    }

    // =============================
    // è°œé¢˜å¡ç‰‡
    // =============================

    function createPuzzleCard(puzzle, index) {
      const state = puzzleState[puzzle.id];
      const card = document.createElement("article");
      card.className = "puzzle-card";

      const isLocked = index > 0 && !puzzleState[puzzles[index - 1].id].solved;

      const header = document.createElement("div");
      header.className = "puzzle-header";

      const titleBox = document.createElement("div");
      titleBox.className = "puzzle-title";

      const label = document.createElement("div");
      label.className = "puzzle-label";
      label.textContent = `PUZZLE ${index + 1}`;

      const name = document.createElement("div");
      name.className = "puzzle-name";
      name.textContent = puzzle.title;

      titleBox.appendChild(label);
      titleBox.appendChild(name);

      const meta = document.createElement("div");
      meta.className = "puzzle-meta";

      const statusPill = document.createElement("div");
      statusPill.dataset.statusPillFor = puzzle.id;
      if (isLocked) {
        statusPill.className = "pill locked";
        statusPill.textContent = "ğŸ”’ Locked";
      } else if (state.solved) {
        statusPill.className = "pill solved";
        statusPill.textContent = "Solved";
      } else {
        statusPill.className = "pill pending";
        statusPill.textContent = "Pending";
      }

      const attemptsSpan = document.createElement("span");
      attemptsSpan.dataset.attemptsFor = puzzle.id;
      attemptsSpan.textContent = `Attempts: ${state.attempts || 0}`;

      const hintsSpan = document.createElement("span");
      hintsSpan.dataset.hintsFor = puzzle.id;
      hintsSpan.textContent = `Hints: ${state.hintsUsed || 0}`;

      meta.appendChild(statusPill);
      meta.appendChild(attemptsSpan);
      meta.appendChild(hintsSpan);

      header.appendChild(titleBox);
      header.appendChild(meta);

      const body = document.createElement("div");
      body.className = "puzzle-body";

      const inputRow = document.createElement("div");
      inputRow.className = "input-row";

      const input = document.createElement("input");
      input.type = "text";
      input.placeholder = "åœ¨æ­¤è¾“å…¥ç­”æ¡ˆ Â· Type your answer here";
      input.autocomplete = "off";
      input.dataset.inputFor = puzzle.id;

      const checkBtn = document.createElement("button");
      checkBtn.className = "primary";
      checkBtn.textContent = "Check";
      checkBtn.dataset.checkFor = puzzle.id;

      inputRow.appendChild(input);
      inputRow.appendChild(checkBtn);
      body.appendChild(inputRow);

      const controlsRow = document.createElement("div");
      controlsRow.className = "controls-row";

      const hintButtonsBox = document.createElement("div");
      hintButtonsBox.className = "hint-buttons-box";

      const feedback = document.createElement("div");
      feedback.className = "feedback";
      feedback.dataset.feedbackFor = puzzle.id;
      feedback.textContent = "";

      // ä¸ºæ¯ä¸ª hint ç”Ÿæˆä¸€ä¸ªæŒ‰é’®
      for (let i = 0; i < puzzle.hints.length; i++) {
        const hb = document.createElement("button");
        hb.className = "outline small";

        if (puzzle.id === "p6") {
          const group = Math.floor(i / 2) + 1;
          const sub = (i % 2) + 1;
          hb.textContent = `Hint ${group}.${sub}`;
        } else {
          hb.textContent = `Hint ${i + 1}`;
        }

        hb.dataset.hintFor = puzzle.id;
        hb.dataset.hintIndex = String(i);

        const alreadyUsed = !!state.usedHints[i];
        // ä¿®æ”¹è¿™é‡Œï¼šå¦‚æœé¢˜ç›®å·²é”å®šã€hintå·²ä½¿ç”¨æˆ–é¢˜ç›®å·²è§£å†³ï¼Œåˆ™ç¦ç”¨æŒ‰é’®
        if (alreadyUsed || isLocked || state.solved) hb.disabled = true;

        hb.addEventListener("click", () => handleHintClick(puzzle.id, i));
        hintButtonsBox.appendChild(hb);
      }

      controlsRow.appendChild(hintButtonsBox);
      controlsRow.appendChild(feedback);

      const hintLinesBlock = document.createElement("div");
      hintLinesBlock.className = "hint-lines-block";

      for (let i = 0; i < puzzle.hints.length; i++) {
        const hintLine = document.createElement("div");
        hintLine.className = "hint-line";
        hintLine.dataset.hintTextFor = `${puzzle.id}-${i}`;
        if (state.usedHints[i]) {
          hintLine.textContent = puzzle.hints[i] || "";
          hintLine.classList.add("visible");
        }
        hintLinesBlock.appendChild(hintLine);
      }

      body.appendChild(controlsRow);
      body.appendChild(hintLinesBlock);

      card.appendChild(header);
      card.appendChild(body);

      // å¤„ç†é”å®šå’Œå·²è§£å†³çŠ¶æ€
      if (isLocked) {
        input.disabled = true;
        checkBtn.disabled = true;
        feedback.textContent = "å‰é¢çš„é¢˜ç›®éœ€è¦å…ˆè§£å†³æ‰èƒ½è§£é” Â· Previous puzzle must be solved first to unlock.";
        feedback.className = "feedback info";
        card.style.opacity = "0.6";
      } else if (state.solved) {
        input.disabled = true;
        checkBtn.disabled = true;
        feedback.textContent = "è¿™ä¸€é¢˜å·²ç»è§£å‡ºæ¥å•¦ Â· Already solved.";
        feedback.className = "feedback success";
      }

      checkBtn.addEventListener("click", () => handleCheckAnswer(puzzle.id));
      input.addEventListener("keydown", e => {
        if (e.key === "Enter") {
          e.preventDefault();
          handleCheckAnswer(puzzle.id);
        }
      });

      return card;
    }

    function renderPuzzleList() {
      const container = document.getElementById("puzzle-list");
      container.innerHTML = "";
      puzzles.forEach((p, idx) =>
        container.appendChild(createPuzzleCard(p, idx))
      );
    }

    // =============================
    // ç­”æ¡ˆæ ¡éªŒ + å†·å´
    // =============================

    function normalizeAnswer(str) {
      return str.trim().replace(/\s+/g, " ").toUpperCase();
    }

    function handleCheckAnswer(puzzleId) {
      const puzzle = puzzles.find(p => p.id === puzzleId);
      if (!puzzle) return;
      const state = puzzleState[puzzleId];
      const now = Date.now();

      const input = document.querySelector(`input[data-input-for="${puzzleId}"]`);
      const feedback = document.querySelector(
        `.feedback[data-feedback-for="${puzzleId}"]`
      );
      const statusPill = document.querySelector(
        `.pill[data-status-pill-for="${puzzleId}"]`
      );
      const attemptsSpan = document.querySelector(
        `[data-attempts-for="${puzzleId}"]`
      );

      if (!input || !feedback || !statusPill || !attemptsSpan) return;

      const raw = input.value;
      if (!raw.trim()) {
        feedback.textContent = "è¯·å…ˆè¾“å…¥ç­”æ¡ˆ Â· Please enter an answer first.";
        feedback.className = "feedback error";
        return;
      }

      if (state.solved) {
        feedback.textContent = "è¿™ä¸€é¢˜å·²ç»è§£å‡ºæ¥å•¦ Â· Already solved.";
        feedback.className = "feedback success";
        return;
      }

      const timeSinceLast = now - state.lastAttemptAt;
      if (state.lastAttemptAt !== 0 && timeSinceLast < MIN_INTERVAL_MS) {
        const waitMs = MIN_INTERVAL_MS - timeSinceLast;
        const waitSec = Math.ceil(waitMs / 1000);
        feedback.textContent =
          `è¯·å†ç­‰ ${waitSec} ç§’åå†å°è¯• Â· Please wait ${waitSec} more second(s) before trying again.`;
        feedback.className = "feedback error";
        return;
      }

      const normalizedInput = normalizeAnswer(raw);
      const expected = normalizeAnswer(puzzle.expectedAnswer);

      state.lastAttemptAt = now;
      state.attempts += 1;
      attemptsSpan.textContent = `Attempts: ${state.attempts}`;
      saveStateToStorage();

      if (normalizedInput === expected) {
        state.solved = true;
        feedback.textContent =
          "æ­£ç¡®ï¼è¯¥ç­”æ¡ˆå·²é”å®š Â· Correct! This answer is locked in.";
        feedback.className = "feedback success";

        statusPill.textContent = "Solved";
        statusPill.classList.remove("pending");
        statusPill.classList.add("solved");

        input.disabled = true;
        const checkBtn = document.querySelector(
          `button[data-check-for="${puzzleId}"]`
        );
        if (checkBtn) checkBtn.disabled = true;

        saveStateToStorage();
        renderPhraseBar();
        renderPuzzleList();
      } else {
        feedback.textContent =
          "æš‚æ—¶ä¸å¯¹ï¼Œå†·å´ç»“æŸåå†è¯•ä¸€æ¬¡ Â· That doesn't quite match. Try again after the cooldown.";
        feedback.className = "feedback error";
      }
    }

    // =============================
    // æç¤ºé€»è¾‘
    // =============================

    function handleHintClick(puzzleId, hintIndex) {
      const puzzle = puzzles.find(p => p.id === puzzleId);
      if (!puzzle) return;
      const state = puzzleState[puzzleId];

      const feedback = document.querySelector(
        `.feedback[data-feedback-for="${puzzleId}"]`
      );
      const hintsSpan = document.querySelector(
        `[data-hints-for="${puzzleId}"]`
      );
      const hintLine = document.querySelector(
        `.hint-line[data-hint-text-for="${puzzleId}-${hintIndex}"]`
      );
      const hintBtn = document.querySelector(
        `button[data-hint-for="${puzzleId}"][data-hint-index="${hintIndex}"]`
      );

      if (!feedback || !hintsSpan || !hintLine || !hintBtn) return;

      if (state.usedHints[hintIndex]) {
        hintLine.classList.add("visible");
        feedback.textContent =
          "è¿™ä¸€æ¡æç¤ºå·²ç»ç”¨è¿‡äº† Â· This hint has already been used for this puzzle.";
        feedback.className = "feedback info";
        return;
      }

      state.usedHints[hintIndex] = true;
      state.hintsUsed += 1;

      const text = puzzle.hints[hintIndex] || "Hint not configured.";
      hintLine.textContent = text;
      hintLine.classList.add("visible");

      hintBtn.disabled = true;
      hintsSpan.textContent = `Hints Used: ${state.hintsUsed}`;

      feedback.textContent =
        "å·²ä½¿ç”¨æç¤ºï¼Œæ€»æ—¶é—´å·²å¢åŠ  5 åˆ†é’Ÿ Â· Hint used. +5 minutes added to total time.";
      feedback.className = "feedback info";

      saveStateToStorage();
      updateTimerDisplay();
    }

    function getTotalHintsUsed() {
      return Object.values(puzzleState).reduce(
        (sum, s) => sum + (s.hintsUsed || 0),
        0
      );
    }

    // =============================
    // è®¡æ—¶å™¨
    // =============================

    function formatTime(ms) {
      if (ms < 0) ms = 0;
      const totalSeconds = Math.floor(ms / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(
        2,
        "0"
      )}`;
    }

    function computeBaseElapsedMs() {
      let elapsed = elapsedBeforePause;
      if (timerStartTimestamp !== null) {
        elapsed = Date.now() - timerStartTimestamp + elapsedBeforePause;
      }
      return elapsed;
    }

    function updateTimerDisplay() {
      const display = document.getElementById("timer-display");
      const totalDisplay = document.getElementById("total-time-display");
      const hintsDisplay = document.getElementById("hints-used-display");
      if (!display || !totalDisplay || !hintsDisplay) return;

      const baseElapsed = computeBaseElapsedMs();
      const totalHints = getTotalHintsUsed();
      const penaltyMs = totalHints * HINT_PENALTY_MS;
      const totalMs = baseElapsed + penaltyMs;

      display.textContent = formatTime(baseElapsed);
      totalDisplay.textContent = formatTime(totalMs);
      hintsDisplay.textContent = totalHints;
    }

    function startTimer() {
      if (timerIntervalId !== null) return;
      if (timerStartTimestamp === null) {
        timerStartTimestamp = Date.now();
        saveStateToStorage();
      }
      timerIntervalId = setInterval(updateTimerDisplay, 250);
      updateTimerDisplay();
    }

    function resetGame() {
      if (timerIntervalId !== null) {
        clearInterval(timerIntervalId);
        timerIntervalId = null;
      }
      timerStartTimestamp = null;
      elapsedBeforePause = 0;

      puzzles.forEach(p => {
        puzzleState[p.id] = {
          lastAttemptAt: 0,
          solved: false,
          attempts: 0,
          hintsUsed: 0,
          usedHints: []
        };
      });

      saveStateToStorage();
      renderPuzzleList();
      renderPhraseBar();
      updateTimerDisplay();
    }

    // =============================
    // åˆå§‹åŒ–
    // =============================

    document.addEventListener("DOMContentLoaded", () => {
      loadStateFromStorage();
      renderPuzzleList();
      renderPhraseBar();
      updateTimerDisplay();

      if (timerStartTimestamp !== null) {
        timerIntervalId = setInterval(updateTimerDisplay, 250);
      }

      const startBtn = document.getElementById("start-timer-btn");
      const resetBtn = document.getElementById("reset-timer-btn");

      if (startBtn) {
        startBtn.addEventListener("click", () => {
          startTimer();
        });
      }

      if (resetBtn) {
        resetBtn.addEventListener("click", () => {
          if (
            confirm(
              "æ˜¯å¦é‡ç½®å…¨éƒ¨è°œé¢˜ä¸è®¡æ—¶ï¼Œä¾›ä¸‹ä¸€é˜Ÿä½¿ç”¨ï¼Ÿ\n\nAre you sure you want to reset all puzzles and the timer for the next team?"
            )
          ) {
            resetGame();
          }
        });
      }
    });
  </script>
</body>
</html>
